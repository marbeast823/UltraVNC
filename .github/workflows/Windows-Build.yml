name: Build UltraVNC â€” Windows x64 Release (Retarget & Resource Include)
on:
  push:
  pull_request:
  workflow_dispatch:
env:
  CONFIGURATION: Release
  PLATFORM: x64
jobs:
  build-windows-x64:
    name: Build (windows-latest, x64, Release)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild (adds msbuild to PATH)
        uses: microsoft/setup-msbuild@v1.1

      - name: Detect Visual Studio / MSVC / Windows SDK and create Directory.Build.props
        shell: pwsh
        run: |
          Write-Host "Detecting Visual Studio installation path (vswhere)..."
          # Get ProgramFiles(x86) safely
          $progFilesX86 = if ($env:ProgramFiles(x86)) { $env:ProgramFiles(x86) } else { "C:\Program Files (x86)" }

          # Find vswhere.exe (check common paths)
          $vswherePath = Join-Path $progFilesX86 "Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswherePath)) {
            # Try well-known alternate path (some runners)
            $vswherePath = Join-Path "C:\Program Files" "Microsoft Visual Studio\Installer\vswhere.exe"
          }
          if (-not (Test-Path $vswherePath)) {
            Write-Error "vswhere.exe not found on runner. Cannot detect Visual Studio installation. Aborting."
            exit 1
          }
          
          # Find latest VS installation with C++ tools
          $instPath = & $vswherePath -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (-not $instPath) {
            Write-Error "Visual Studio installation with VC tools not found via vswhere."
            exit 1
          }
          Write-Host "Visual Studio installationPath: $instPath"

          # Find MSVC toolset directory (pick highest version)
          $msvcRoot = Join-Path $instPath "VC\Tools\MSVC"
          if (-not (Test-Path $msvcRoot)) {
            Write-Error "MSVC root not found at $msvcRoot"
            exit 1
          }
          $msvcVer = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (-not $msvcVer) {
            Write-Error "No MSVC toolset found under $msvcRoot"
            exit 1
          }
          $msvcDir = Join-Path $msvcRoot $msvcVer.Name
          Write-Host "Using MSVC toolset: $msvcVer.Name"

          # Construct atlmfc include path (contains afxres.h)
          $atlmfcInclude = Join-Path $msvcDir "atlmfc\include"
          if (-not (Test-Path $atlmfcInclude)) {
            Write-Warning "ATLMFC include path not found at $atlmfcInclude. Continuing, but rc may still fail to find afxres.h."
            $additionalInclude = ""
          } else {
            Write-Host "Found ATLMFC include: $atlmfcInclude"
            $additionalInclude = $atlmfcInclude
          }

          # Detect highest installed Windows 10 SDK include version
          $win10IncludeRoot = "C:\Program Files (x86)\Windows Kits\10\Include"
          $sdkVersion = ""
          if (Test-Path $win10IncludeRoot) {
            $sdkVersionDir = Get-ChildItem -Path $win10IncludeRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            if ($sdkVersionDir) {
              $sdkVersion = $sdkVersionDir.Name
              Write-Host "Detected Windows 10 SDK version: $sdkVersion"
            }
          }

          # If windows 10 sdk found use it; else fallback to an empty value (do not override)
          if ($sdkVersion -ne "") {
            $windowsTargetPlatformVersion = $sdkVersion
          } else {
            $windowsTargetPlatformVersion = ""
          }

          # --- Construct the Directory.Build.props content ---
          
          # 1. WindowsTargetPlatformVersion PropertyGroup - construct a clean block if version is available
          $winPropBlock = ""
          if ($windowsTargetPlatformVersion -ne "") {
              $winPropBlock = @"
  <!-- 
  If WindowsTargetPlatformVersion is not explicitly defined in the project or environment, 
  set it to the highest detected SDK version for retargeting.
  This helps resolve MSB8036 (The Windows SDK version was not found).
  -->
  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)' == ''">
    <WindowsTargetPlatformVersion>$windowsTargetPlatformVersion</WindowsTargetPlatformVersion>
  </PropertyGroup>
"@
          }

          # 2. ResourceCompile ItemDefinitionGroup - construct a clean block if include path is available
          $rcIncBlock = ""
          if ($additionalInclude -ne "") {
              $rcIncBlock = @"
  <!-- 
  Add the MSVC ATL/MFC include directory to ResourceCompile, which contains afxres.h. 
  This fixes errors for resource files that reference Visual Studio resource headers.
  -->
  <ItemDefinitionGroup>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$additionalInclude;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
"@
          }

          # The multi-line string definition for the .props file
          $propsContent = @"
<Project>
$winPropBlock
$rcIncBlock
</Project>
"@
          
          # Save the content to the file
          $propsPath = Join-Path $env:GITHUB_WORKSPACE "Directory.Build.props"
          Set-Content -Path $propsPath -Value $propsContent -Encoding UTF8
          
          # Output the content for logging
          Write-Host "Directory.Build.props created. Contents:"
          Get-Content -Path $propsPath | ForEach-Object { Write-Host $_ }

      - name: Find solution file
        id: find_sln
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Recurse -Filter *.sln -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $sln) {
            Write-Error "No .sln file found in repository. Ensure your solution (.sln) is committed."
            exit 1
          }
          Write-Host "Found solution: $($sln.FullName)"
          echo "sln=$($sln.FullName)" >> $env:GITHUB_OUTPUT

      - name: Restore NuGet packages (if needed)
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          $nuget = Join-Path $env:GITHUB_WORKSPACE 'nuget.exe'
          if (-not (Test-Path $nuget)) {
            Write-Host "Downloading nuget.exe..."
            Invoke-WebRequest -Uri 'https://dist.nuget.org/win-x86-commandline/latest/nuget.exe' -OutFile $nuget
          }
          Write-Host "Running nuget restore on $sln"
          & $nuget restore "$sln"

      - name: Build solution with MSBuild
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          Write-Host "Building solution: $sln"
          msbuild "$sln" /p:Configuration=${{ env.CONFIGURATION }} /p:Platform=${{ env.PLATFORM }} /m /t:Rebuild

      - name: Package build outputs (zip)
        id: package
        shell: pwsh
        run: |
          $ws = $env:GITHUB_WORKSPACE
          $outZip = Join-Path $ws 'artifacts' 'UltraVNC-x64-Release.zip'
          New-Item -ItemType Directory -Path (Split-Path $outZip) -Force | Out-Null

          # Search for common release directories
          $releaseDirs = Get-ChildItem -Path $ws -Recurse -Directory -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -match '\\x64\\Release$' -or $_.FullName -match '\\Release$' -or $_.FullName -match '\\bin\\Release$' }

          $files = @()
          if ($releaseDirs -and $releaseDirs.Count -gt 0) {
            foreach ($d in $releaseDirs) {
              $files += Get-ChildItem -Path $d.FullName -Recurse -File -ErrorAction SilentlyContinue
            }
          } else {
            # Fallback to general search for executables, libraries, and installers
            $files = Get-ChildItem -Path $ws -Recurse -Include *.exe,*.dll,*.msi -File -ErrorAction SilentlyContinue
          }

          if (-not $files -or $files.Count -eq 0) {
            Write-Error "No build artifacts found to package."
            exit 1
          }

          $tempDir = Join-Path $env:TEMP ('ultravnc-pack-' + [guid]::NewGuid().ToString())
          New-Item -ItemType Directory -Path $tempDir | Out-Null
          
          # Copy files to a flat directory structure for zipping
          foreach ($f in $files) {
            $dest = Join-Path $tempDir (Split-Path $f.FullName -Leaf)
            Copy-Item -Path $f.FullName -Destination $dest -Force
          }

          if (Test-Path $outZip) { Remove-Item $outZip -Force }
          Compress-Archive -Path (Join-Path $tempDir '*') -DestinationPath $outZip -Force
          Remove-Item -Recurse -Force $tempDir

          echo "artifact=$outZip" >> $env:GITHUB_OUTPUT

      - name: Upload artifact (UltraVNC x64 Release)
        uses: actions/upload-artifact@v4
        with:
          name: UltraVNC-x64-Release
          path: ${{ steps.package.outputs.artifact }}
