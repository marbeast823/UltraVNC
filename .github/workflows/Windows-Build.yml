name: Build UltraVNC â€” Windows x64 Release (Retarget & Resource Include)
on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

env:
  CONFIGURATION: Release
  PLATFORM: x64

jobs:
  build-windows-x64:
    name: Build (windows-latest, x64, Release)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild (adds msbuild to PATH)
        uses: microsoft/setup-msbuild@v1.1

      - name: Detect Visual Studio / MSVC / Windows SDK and create Directory.Build.props
        shell: pwsh
        run: |
          Write-Host "Detecting vswhere.exe (search PATH and well-known locations)..."

          # Try to find vswhere in PATH first
          $vswhereCmd = Get-Command vswhere.exe -ErrorAction SilentlyContinue
          if ($vswhereCmd) {
            $vswherePath = $vswhereCmd.Source
          } else {
            $progFilesX86 = if { $env:ProgramFiles(x86) } else { "C:\Program Files (x86)" }
            $pathsToTry = @(
              (Join-Path $progFilesX86 "Microsoft Visual Studio\Installer\vswhere.exe"),
              "C:\Program Files\Microsoft Visual Studio\Installer\vswhere.exe"
            )
            $vswherePath = $null
            foreach ($p in $pathsToTry) {
              if (Test-Path $p) { $vswherePath = $p; break }
            }
          }

          if (-not $vswherePath) {
            Write-Error "vswhere.exe not found on runner. Cannot detect Visual Studio installation. Aborting."
            exit 1
          }
          Write-Host "vswhere found at: $vswherePath"

          # Get installation path for an instance with C++ tools
          $instPathRaw = & $vswherePath -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath 2>$null
          if (-not $instPathRaw) {
            Write-Error "Visual Studio installation with VC tools not found via vswhere."
            exit 1
          }
          # vswhere may output newline(s); take the first non-empty trimmed line
          $instPath = ($instPathRaw -split "`r?`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" })[0]
          if (-not $instPath) {
            Write-Error "Failed to parse installationPath from vswhere output."
            exit 1
          }
          Write-Host "Visual Studio installationPath: $instPath"

          # Find MSVC toolset directory (pick highest version)
          $msvcRoot = Join-Path $instPath "VC\Tools\MSVC"
          if (-not (Test-Path $msvcRoot)) {
            Write-Warning "MSVC root not found at $msvcRoot - resource includes may be missing."
            $msvcDir = ""
          } else {
            $msvcVer = Get-ChildItem -Path $msvcRoot -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending | Select-Object -First 1
            if ($msvcVer) {
              $msvcDir = Join-Path $msvcRoot $msvcVer.Name
              Write-Host "Using MSVC toolset: $msvcVer.Name"
            } else {
              Write-Warning "No MSVC toolset directories found under $msvcRoot."
              $msvcDir = ""
            }
          }

          # Construct atlmfc include path (contains afxres.h) if present
          $atlmfcInclude = ""
          if ($msvcDir -ne "") {
            $candidate = Join-Path $msvcDir "atlmfc\include"
            if (Test-Path $candidate) {
              $atlmfcInclude = $candidate
              Write-Host "Found ATLMFC include: $atlmfcInclude"
            } else {
              Write-Warning "ATLMFC include path not found at $candidate. Resource compile may fail to find afxres.h."
            }
          }

          # Detect highest installed Windows SDK include version (Windows 10/11)
          $winIncludeRoot = "C:\Program Files (x86)\Windows Kits\10\Include"
          $sdkVersion = ""
          if (Test-Path $winIncludeRoot) {
            $sdkVersionDir = Get-ChildItem -Path $winIncludeRoot -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending | Select-Object -First 1
            if ($sdkVersionDir) {
              $sdkVersion = $sdkVersionDir.Name
              Write-Host "Detected Windows SDK version: $sdkVersion"
            }
          }

          if ($sdkVersion -ne "") {
            $windowsTargetPlatformVersion = $sdkVersion
          } else {
            $windowsTargetPlatformVersion = ""
            Write-Warning "Windows SDK include version not detected. Will not override WindowsTargetPlatformVersion."
          }

          # Build Directory.Build.props content (include XML declaration)
          $propsLines = New-Object System.Collections.Generic.List[string]
          $propsLines.Add('<?xml version="1.0" encoding="utf-8"?>')
          $propsLines.Add('<Project>')

          if ($windowsTargetPlatformVersion -ne "") {
            $propsLines.Add('  <!-- Set the Windows SDK version if not already specified to avoid MSB8036 -->')
            $propsLines.Add("  <PropertyGroup Condition=`"'$(WindowsTargetPlatformVersion)' == ''`">")
            $propsLines.Add("    <WindowsTargetPlatformVersion>$windowsTargetPlatformVersion</WindowsTargetPlatformVersion>")
            $propsLines.Add('  </PropertyGroup>')
          }

          if ($atlmfcInclude -ne "") {
            # Escape ampersands etc. (path typically does not contain XML-sensitive chars but be safe)
            $escapedInclude = [System.Security.SecurityElement]::Escape($atlmfcInclude)
            $propsLines.Add('  <!-- Add ATL/MFC include directory to ResourceCompile so resource compiler can find afxres.h -->')
            $propsLines.Add('  <ItemDefinitionGroup>')
            $propsLines.Add('    <ResourceCompile>')
            $propsLines.Add("      <AdditionalIncludeDirectories>$escapedInclude;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>")
            $propsLines.Add('    </ResourceCompile>')
            $propsLines.Add('  </ItemDefinitionGroup>')
          }

          $propsLines.Add('</Project>')

          $propsPath = Join-Path $env:GITHUB_WORKSPACE "Directory.Build.props"
          $propsLines -join "`n" | Out-File -FilePath $propsPath -Encoding utf8 -Force

          Write-Host "Directory.Build.props created at: $propsPath"
          Get-Content $propsPath | ForEach-Object { Write-Host "  $_" }

      - name: Find solution file
        id: find_sln
        shell: pwsh
        run: |
          # Prefer top-level .sln; fallback to first found anywhere
          $workspace = $env:GITHUB_WORKSPACE
          $sln = Get-ChildItem -Path $workspace -Filter *.sln -File -Depth 1 -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $sln) {
            $sln = Get-ChildItem -Path $workspace -Recurse -Filter *.sln -File -ErrorAction SilentlyContinue | Select-Object -First 1
          }
          if (-not $sln) {
            Write-Error "No .sln file found in repository. Ensure your solution (.sln) is committed."
            exit 1
          }
          Write-Host "Found solution: $($sln.FullName)"
          # Export for subsequent steps
          Add-Content -Path $env:GITHUB_OUTPUT -Value ("sln=" + $sln.FullName)

      - name: Restore NuGet packages (if needed)
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          $nuget = Join-Path $env:GITHUB_WORKSPACE 'nuget.exe'
          if (-not (Test-Path $nuget)) {
            Write-Host "Downloading nuget.exe..."
            Invoke-WebRequest -Uri 'https://dist.nuget.org/win-x86-commandline/latest/nuget.exe' -OutFile $nuget
          }
          Write-Host "Running nuget restore on $sln"
          & $nuget restore "$sln"

      - name: Build solution with MSBuild
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          Write-Host "Building solution: $sln"
          # Use msbuild from PATH (added by setup-msbuild). Use /m to parallelize if possible.
          msbuild "$sln" /p:Configuration=${{ env.CONFIGURATION }} /p:Platform=${{ env.PLATFORM }} /m /t:Rebuild

      - name: Package build outputs (zip)
        id: package
        shell: pwsh
        run: |
          $ws = $env:GITHUB_WORKSPACE
          $outZip = Join-Path $ws 'artifacts' 'UltraVNC-x64-Release.zip'
          New-Item -ItemType Directory -Path (Split-Path $outZip) -Force | Out-Null

          # Search for common release directories (prefer x64\Release first)
          $releaseDirs = Get-ChildItem -Path $ws -Recurse -Directory -ErrorAction SilentlyContinue |
            Where-Object {
              # Normalize path separators and test patterns
              $p = $_.FullName -replace '/', '\'
              ($p -match '\\x64\\Release$') -or ($p -match '\\x64\\bin\\Release$') -or ($p -match '\\bin\\x64\\Release$') -or ($p -match '\\Release$')
            }

          $files = @()
          if ($releaseDirs -and $releaseDirs.Count -gt 0) {
            foreach ($d in $releaseDirs) {
              $files += Get-ChildItem -Path $d.FullName -Recurse -File -ErrorAction SilentlyContinue
            }
          } else {
            # Fallback: common artifact file types
            $files = Get-ChildItem -Path $ws -Recurse -Include *.exe,*.dll,*.msi -File -ErrorAction SilentlyContinue
          }

          if (-not $files -or $files.Count -eq 0) {
            Write-Error "No build artifacts found to package."
            exit 1
          }

          $tempDir = Join-Path $env:TEMP ('ultravnc-pack-' + [guid]::NewGuid().ToString())
          New-Item -ItemType Directory -Path $tempDir | Out-Null

          # Copy files to a flat directory structure for zipping (avoid collisions by prefixing if necessary)
          foreach ($f in $files) {
            $leaf = (Split-Path $f.FullName -Leaf)
            $dest = Join-Path $tempDir $leaf
            $counter = 1
            while (Test-Path $dest) {
              # append numeric suffix if collision
              $dest = Join-Path $tempDir ("{0}_{1}{2}" -f ([IO.Path]::GetFileNameWithoutExtension($leaf)), $counter, [IO.Path]::GetExtension($leaf))
              $counter++
            }
            Copy-Item -Path $f.FullName -Destination $dest -Force
          }

          if (Test-Path $outZip) { Remove-Item $outZip -Force }
          Compress-Archive -Path (Join-Path $tempDir '*') -DestinationPath $outZip -CompressionLevel Optimal -Force
          Remove-Item -Recurse -Force $tempDir

          Add-Content -Path $env:GITHUB_OUTPUT -Value ("artifact=" + $outZip)

      - name: Upload artifact (UltraVNC x64 Release)
        uses: actions/upload-artifact@v4
        with:
          name: UltraVNC-x64-Release
          path: ${{ steps.package.outputs.artifact }}
