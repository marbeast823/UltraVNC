# GitHub Actions workflow: Build UltraVNC — Windows x64 Release (retarget SDK + resource include fix)
#
# This workflow:
# - Detects the Visual Studio/MSVC and Windows 10 SDK installed on the runner using vswhere and file system.
# - Creates a Directory.Build.props at repo root that:
#    * retargets projects that request Windows SDK 8.1 -> to an installed Windows 10 SDK version (avoids MSB8036)
#    * adds the MSVC atlmfc/include path to resource compile AdditionalIncludeDirectories so rc.exe can find afxres.h (avoids RC1015)
# - Builds the solution with MSBuild for Configuration=Release and Platform=x64
# - Packages outputs into a zip and uploads as an artifact
#
# Notes:
# - This approach does not modify individual .vcxproj files; it creates a repo-level override (Directory.Build.props)
#   so you can keep the upstream project files untouched and still build on hosted runners that don't have SDK 8.1.
# - If a project strictly requires Windows SDK 8.1 features (not present in newer SDKs), you will need to install SDK 8.1
#   on the runner or build on a self-hosted machine that has it.
#
name: Build UltraVNC — Windows x64 Release (Retarget & Resource Include)

on:
  push:
  pull_request:
  workflow_dispatch:

env:
  CONFIGURATION: Release
  PLATFORM: x64

jobs:
  build-windows-x64:
    name: Build (windows-latest, x64, Release)
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild (adds msbuild to PATH)
        uses: microsoft/setup-msbuild@v1.1

      - name: Detect Visual Studio / MSVC / Windows SDK and create Directory.Build.props
        shell: pwsh
        run: |
          Write-Host "Detecting Visual Studio installation path (vswhere)..."
          $vswhere = "${{ envProgramFilesX86 := $env:ProgramFiles(x86) }}"
          $vswherePath = Join-Path $env:ProgramFiles "(x86)\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswherePath)) {
            # Try well-known alternate path (some runners)
            $vswherePath = Join-Path $env:ProgramFiles "Microsoft Visual Studio\Installer\vswhere.exe"
          }
          if (-not (Test-Path $vswherePath)) {
            Write-Error "vswhere.exe not found on runner. Cannot detect Visual Studio installation. Aborting."
            exit 1
          }
          $instPath = & $vswherePath -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (-not $instPath) {
            Write-Error "Visual Studio installation with VC tools not found via vswhere."
            exit 1
          }
          Write-Host "Visual Studio installationPath: $instPath"

          # Find MSVC toolset directory (pick highest version)
          $msvcRoot = Join-Path $instPath "VC\Tools\MSVC"
          if (-not (Test-Path $msvcRoot)) {
            Write-Error "MSVC root not found at $msvcRoot"
            exit 1
          }
          $msvcVer = Get-ChildItem -Path $msvcRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
          if (-not $msvcVer) {
            Write-Error "No MSVC toolset found under $msvcRoot"
            exit 1
          }
          $msvcDir = Join-Path $msvcRoot $msvcVer.Name
          Write-Host "Using MSVC toolset: $msvcVer.Name"

          # Construct atlmfc include path (contains afxres.h)
          $atlmfcInclude = Join-Path $msvcDir "atlmfc\include"
          if (-not (Test-Path $atlmfcInclude)) {
            Write-Warning "ATLMFC include path not found at $atlmfcInclude. Continuing, but rc may still fail to find afxres.h."
          } else {
            Write-Host "Found ATLMFC include: $atlmfcInclude"
          }

          # Detect highest installed Windows 10 SDK include version
          $win10IncludeRoot = "C:\Program Files (x86)\Windows Kits\10\Include"
          if (-not (Test-Path $win10IncludeRoot)) {
            Write-Warning "Windows Kits 10 include root not found at $win10IncludeRoot. MSBuild may still succeed if projects use installed defaults."
            $sdkVersion = ""
          } else {
            $sdkVersionDir = Get-ChildItem -Path $win10IncludeRoot -Directory | Sort-Object Name -Descending | Select-Object -First 1
            if ($sdkVersionDir) {
              $sdkVersion = $sdkVersionDir.Name
              Write-Host "Detected Windows 10 SDK version: $sdkVersion"
            } else {
              $sdkVersion = ""
            }
          }

          # If windows 10 sdk found use it; else fallback to an empty value (do not overwrite)
          if ($sdkVersion -and $sdkVersion -ne "") {
            $windowsTargetPlatformVersion = $sdkVersion
          } else {
            $windowsTargetPlatformVersion = ""
          }

          # Create Directory.Build.props to retarget and add resource include directories
          $propsPath = Join-Path $env:GITHUB_WORKSPACE "Directory.Build.props"
          Write-Host "Writing Directory.Build.props to $propsPath"
          $additionalInclude = $null
          if (Test-Path $atlmfcInclude) {
            # Use MSVC atlmfc include absolute path so rc.exe can find afxres.h
            $additionalInclude = $atlmfcInclude
          } else {
            $additionalInclude = ""
          }

          $propsContent = @"

          # The above uses PowerShell interpolation; write with correct content
          if ($windowsTargetPlatformVersion -ne "") {
            $winProp = "<WindowsTargetPlatformVersion>$windowsTargetPlatformVersion</WindowsTargetPlatformVersion>"
          } else {
            $winProp = ""
          }
          if ($additionalInclude -ne "") {
            $incProp = "<AdditionalIncludeDirectories>$additionalInclude;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>"
          } else {
            $incProp = ""
          }

          $final = "<Project>`n  <PropertyGroup>`n    $winProp`n  </PropertyGroup>`n  <ItemDefinitionGroup>`n    <ResourceCompile>`n      $incProp`n    </ResourceCompile>`n  </ItemDefinitionGroup>`n</Project>`n"
          Set-Content -Path $propsPath -Value $final -Encoding UTF8

          Write-Host "Directory.Build.props created. Contents:"
          Get-Content -Path $propsPath | ForEach-Object { Write-Host $_ }

      - name: Find solution file
        id: find_sln
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Recurse -Filter *.sln -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $sln) {
            Write-Error "No .sln file found in repository. Ensure your solution (.sln) is committed."
            exit 1
          }
          Write-Host "Found solution: $($sln.FullName)"
          echo "sln=$($sln.FullName)" >> $env:GITHUB_OUTPUT

      - name: Restore NuGet packages (if needed)
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          $nuget = Join-Path $env:GITHUB_WORKSPACE 'nuget.exe'
          if (-not (Test-Path $nuget)) {
            Write-Host "Downloading nuget.exe..."
            Invoke-WebRequest -Uri 'https://dist.nuget.org/win-x86-commandline/latest/nuget.exe' -OutFile $nuget
          }
          Write-Host "Running nuget restore on $sln"
          & $nuget restore "$sln"

      - name: Build solution with MSBuild
        shell: pwsh
        run: |
          $sln = '${{ steps.find_sln.outputs.sln }}'
          Write-Host "Building solution: $sln"
          msbuild "$sln" /p:Configuration=${{ env.CONFIGURATION }} /p:Platform=${{ env.PLATFORM }} /m /t:Rebuild

      - name: Package build outputs (zip)
        id: package
        shell: pwsh
        run: |
          $ws = $env:GITHUB_WORKSPACE
          $outZip = Join-Path $ws 'artifacts' 'UltraVNC-x64-Release.zip'
          New-Item -ItemType Directory -Path (Split-Path $outZip) -Force | Out-Null

          $releaseDirs = Get-ChildItem -Path $ws -Recurse -Directory -ErrorAction SilentlyContinue |
                         Where-Object { $_.FullName -match '\\x64\\Release$' -or $_.FullName -match '\\Release$' -or $_.FullName -match '\\bin\\Release$' }

          $files = @()
          if ($releaseDirs -and $releaseDirs.Count -gt 0) {
            foreach ($d in $releaseDirs) {
              $files += Get-ChildItem -Path $d.FullName -Recurse -File -ErrorAction SilentlyContinue
            }
          } else {
            $files = Get-ChildItem -Path $ws -Recurse -Include *.exe,*.dll,*.msi -File -ErrorAction SilentlyContinue
          }

          if (-not $files -or $files.Count -eq 0) {
            Write-Error "No build artifacts found to package."
            exit 1
          }

          $tempDir = Join-Path $env:TEMP ('ultravnc-pack-' + [guid]::NewGuid().ToString())
          New-Item -ItemType Directory -Path $tempDir | Out-Null
          foreach ($f in $files) {
            $dest = Join-Path $tempDir (Split-Path $f.FullName -Leaf)
            Copy-Item -Path $f.FullName -Destination $dest -Force
          }

          if (Test-Path $outZip) { Remove-Item $outZip -Force }
          Compress-Archive -Path (Join-Path $tempDir '*') -DestinationPath $outZip -Force
          Remove-Item -Recurse -Force $tempDir

          echo "artifact=$outZip" >> $env:GITHUB_OUTPUT

      - name: Upload artifact (UltraVNC x64 Release)
        uses: actions/upload-artifact@v4
        with:
          name: UltraVNC-x64-Release
          path: ${{ steps.package.outputs.artifact }}
